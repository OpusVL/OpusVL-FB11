
package OpusVL::FB11X::ResultsetSearch::Controller::ResultSetSearch;

use Moose;
use namespace::autoclean;

BEGIN { extends 'Catalyst::Controller::HTML::FormFu'; }

with 'OpusVL::FB11::RolesFor::Controller::GUI';

=head1 EazyCollect Search Controller

The idea for this is that we might eventually develop in into a standalone
package for fb11. Its will/may be used to provide a consistent search method
across the application

=cut

sub auto
	: Private
{
	my $self = shift;
	my $c    = shift;
}

=head2 auto

=head2 search_results

This is the bread and butter method. It requires the following objects on the
stash:

=over

=item form

The form object to use. Make sure you set FormConfig on the calling action and
initialise it with the appropriate config path

=item resultset

The initial resultset to search on

=back

Alternatively it can be called like this,

	my $search_args = 
	[{
		sort_defs => [ 
            [ name => 'Name' ],
        ],
        search_methods => [
            [ global_fields => 'with_fields' ],
        ],
		resultset => $rs,
	}];

	$c->forward ('/modules/resultsetsearch/search_results' => $search_args);

=head3 formfu forms

Here is an example formfu form of the sort that the controller expects
to be setup.

      - type: Fieldset
        legend: Search Terms
        elements:

          - type: Text
            name: name li
            label: Name

          - type: Text
            name: outlet/name li
            label: Outlet Name

          - type: Text
            name: global_fields__test li
            label: Test

          - type: Text
            name: global_fields__second_field
            label: Second

The names of the fields are expected to relate to fieldnames
on the resultset passed in.  Names starting with an underscore
are ignored in the search.

FormFu doesn't allow .'s in it's names, so to do table.field 
for a search term use / instead.  Make sure that the resultset
you have passed has the join setup otherwise the search will 
fail.  In the example above you'd need to have setup the outlet join.

=head3 field name decorators

In order to allow for different search operators you can decorate 
your field names with extra operators.  Put a space then the operator
you want.  With no decorator the field is just checked with the 
regular equality operator.

=over

=item * gt

Greater than (>=)

=item * lt

Less than (<=)

=item * li

ilike

=item * sw

Starts with

=item * ew

Ends with

=item * in

e.g. WHERE id IN (1,3,4)

=back

=head3 sort_methods

This allows complex order by clauses to be generated by making use of 
a method on the resultset.  If the sort method is selected then the method
will be used instead of simply passing through the field to be sorted by.
The method will be passed the direction to do the order by in, ascending
or descending.

		sort_defs => [ 
            [ 'total_cost' => 'Expected cost' ],
            [ 'me.id' => 'Number' ],
        ],
        sort_methods => {
            'total_cost' => 'by_total_cost',
        },

On the resultset you then have a method like this,

    sub by_total_cost
    {
        my $self = shift;
        my $direction = shift;
        ...

=head3 search methods

The search methods are a list of functions that can be called on the resultset
that has been passed in, and should be called in based on the from element.

With the example form above, the global_fields__test field will be passed to 
the with_fields function as a hash ref, 

e.g. if the user enters 'test' and 'another' as the values
in those two text boxes, the resultset will be called like this,

    $rs = $rs->with_fields({ test => { -like => 'test' }, second_field => 'another' });

This allows you to deal with complex links between objects with the resultset.

When the search is complete, the following keys will be set on the stash:

=over

=item search_done

Set to 1 to indicate we at least tried

=item search_results

A newly created resultset (a subset of the initial resultset) that contains the
results. This will paginated.

=back

=cut

sub search_results
	: Private
{
	my $self      = shift;
	my $c         = shift;
	my $args      = shift;

	my $form      = $c->stash->{form};
	my $resultset = $args->{resultset} || $c->stash->{resultset};
	my $search_results = $resultset;
	my $search_methods = $args->{search_methods};
	my $search_method_args = {};

	if (exists $args->{sort_defs} && $#{ $args->{sort_defs} } > -1)
	{
		$form->get_all_element ({ name => '_sort_key' })->options ($args->{sort_defs});
		$form->process;
	}

	if ($form->submitted_and_valid)
	{
		# Set the search terms. Be sure to only search fields that have data in
		# them, and ensure we ignore input values that come from the submit
		# buttons.

		my $params = $form->params;
		my $terms  = {};

        my $start_date;
        my $end_date;
        if ($params->{start_date} or $params->{end_date}) {
            $start_date = delete $params->{start_date} if $params->{start_date};
            $end_date   = delete $params->{end_date} if $params->{end_date};
        }

		while (my ($field, $value) = each %$params)
		{
			my $is_valid = $value ne ''       &&
			               $field ne 'page'   &&
						   $field !~ /button/ && # better done by using the is_field parameter
						   $field !~ '^_';

			if ($is_valid)
			{
				my $is_method_param = $field =~ /__/;
				my $is_simple_param = !$is_method_param;

				my ($lhs, $op) = $field =~ /^(\S*)( ..|)$/;

				my $rhs = $op eq ' gt' ? { '>='  =>   $value   } : # greater than
						  $op eq ' lt' ? { '<='  =>   $value   } : # less than
						  $op eq ' li' ? { ILIKE => "%$value%" } : # like
						  $op eq ' sw' ? { ILIKE =>  "$value%" } : # starts with
						  $op eq ' ew' ? { ILIKE => "%$value"  } : # ends with
				          $op eq ' in' ? { IN    =>   $value   } : # IN
													  $value       # equality
				;

				if ($lhs && $rhs)
				{
					$lhs =~ tr!/!.!;
					
					if ($is_simple_param)
					{
						# we need to explicitly set "me" so that resultsets
						# obtained from search_related for example work properly.

						my $lhs_has_alias = $lhs =~ /\./;

						unless ($lhs_has_alias)
						{
							my $me = $resultset->current_source_alias;
							$lhs = "$me.$lhs"
						}

						# if we have multiple keys of the same name, switch to
						# using an -and for this key name, else just pass as a
						# normal key/value pair

						if (exists $terms->{$lhs})
						{
							push @{ $terms->{-and} }, { $lhs => $rhs };
						}
						else
						{
							$terms->{$lhs} = $rhs;
						}
					}
					elsif ($is_method_param)
					{
						my ($method, $arg) = $lhs =~ /^(.*)__(.*)$/;
						$search_method_args->{$method}{$arg} = $rhs;
					}
				}
			}
		}

		# now process any search methods that were specified in the arguments,
		# and peel off any parameters that may have been passed.

		if ($search_methods && $#$search_methods > -1)
		{
			foreach my $a (@$search_methods)
			{
				my ($tag, $method) = @$a;
				my $args = $search_method_args->{$tag};

				$search_results = $search_results->$method ($args) if $args;
			}
		}

		# We also may wish to allow the user to select the amount of rows they wish
		# to display in a page, the template doesn't yet support it, but we can
		# enable it easily in the controller

		my $attrs    = {};
		my $page     = $c->req->param('page') || $form->param_value ('page')      || 1;
		my $rows     = $c->req->param('_rows') || $form->param_value ('_rows')     || 15;
		my $order    = $c->req->param('_sort_key') || $form->param_value ('_sort_key');
        unless($order && grep { $_->[0] eq $order } @{$args->{sort_defs}})
        {
            $order = undef; # don't allow an order that is not defined.
        }
        my $sort_dir = $c->req->param('_sort_dir') || $form->param_value ('_sort_dir');
		my $dir      = $sort_dir && $sort_dir eq 'desc' ? '-desc' : '-asc';
        my $search_method = $args->{sort_methods}->{$order};
        if($search_method)
        {
            $order = undef;
            $search_results = $search_results->$search_method($dir);
        }
        else
        {
            my $me = $search_results->current_source_alias;
            $order ||= "$me.id";
            if($order ne "$me.id" && $search_results->result_source->has_column('id'))
            {
                # tag on id to make the limit search safer
                # otherwise you get bitten by the fact SQL doesn't guarantee the order
                # of results any more than you specify them.
                $order = [ $order, "$me.id" ];
            }
        }

		$attrs =
		{
			rows     => $rows,
			page     => $page,
		};
        $attrs->{order_by} = { $dir => $order } if $order;

        # FIXME: need to document these search methods.
        # they are used for pre-canned searches.  The idea is 
        # that you have a set of checkboxes on the form and then 
        # methods get called for each of those check boxes. 
        # as usual, see EazyCollect::ECM for an example of this
        # in use.

		# now we call any preset search methods that may have been passed using
		# the _searches parameter. 

		foreach my $search_key ($form->param_value ('_searches'))
		{
            if($search_key)
            {
                my $method = $args->{search_methods}{$search_key};

                if ($method)
                {
                    my %params = map { /^_search $method (.*)$/ ? ( $1 => $form->param_value ($_) ) : () } keys %{ $form->params };
                    $search_results = $search_results->$method (\%params);
                }
            }
		}

		# now just do the search, set up the pager object and return. we add the
		# resultset object to the stash, rather than an arrayref of actual
		# customers. this is just to defer retrival of the data until the template
		# executes.

        if ($start_date and $end_date) {
            my @d1 = split '/', $start_date;
            my @d2 = split '/', $end_date;
            my $sdt = DateTime->new(day => $d1[0], month => $d1[1], year => $d1[2]);
            my $edt = DateTime->new(day => $d2[0], month => $d2[1], year => $d2[2]);
            
            $terms->{event_date} = { -between => [ $sdt, $edt ] };
        }

		$search_results = $search_results->search_rs ($terms, $attrs);

		$c->stash->{search_done}    = 1;
		$c->stash->{search_results} = $search_results;
	}

	return $search_results;
}

return 1;
