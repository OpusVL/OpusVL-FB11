#!perl

use strict;
use warnings;
use 5.014;

use Pod::Usage;
use Try::Tiny;
use DBIx::Class::DeploymentHandler;
use Getopt::Long qw(:config gnu_getopt);
use File::ShareDir 'module_dir';

my %option = (
    help => sub { pod2usage(verbose => 2) },
);
GetOptions(\%option, 
    'target=f', 
    'help|h|?', 
    'connection-info|c=s', 
    'user|u=s', 
    'password|p=s', 
    'force|f',
    'prepare|ddl!'
);

my $module = shift;
my $command = shift;

eval "require $module";

my $schema = $module->connect({
    dsn => $option{'connection-info'} // '',
    user => $option{'user'},
    password => $option{'password'},
});
my $dh = DBIx::Class::DeploymentHandler->new({ 
    schema => $schema,
    force_overwrite  => $option{force},
    script_directory => module_dir($module) . '/sql',
});

my $version = $option{target} || $schema->schema_version;

my %command = (
    init => \&init,
    downgrade => \&downgrade,
    upgrade => \&upgrade,
    deploy => \&deploy,
    'set-version' => \&set_version,
    prepare => \&prepare,
);

$command{$command || 'upgrade'}->($dh);

sub _ignoring_existing_files(&);

sub init {
    my $dh = shift;

    if ($option{prepare}) {
        # Create source files for this version
        _ignoring_existing_files {
            $dh->prepare_install;
        };
    }

    # Create the versioning table
    $dh->install_version_storage;

    # Register this version in the versioning table
    $dh->add_database_version({ 
        version => $version
    });
}

sub set_version {
    my $dh = shift;

    if ($option{prepare}) {
        _ignoring_existing_files {
            $dh->prepare_install;
        };
    }

    try {
        $dh->add_database_version({ 
            version => $schema->schema_version 
        });
        say "Database set to version $version";
    }
    catch {
        if (/Key.+already exists/) {
            say "Already on version $version";
            return 0;
        }
        else {
            die $_;
        }
    };
}

sub downgrade {
    my $dh = shift;
    if ($option{prepare}) {
        _ignoring_existing_files {
            $dh->prepare_downgrade;
        }
    }

    $dh->downgrade({
        to_version => $version
    });
}

sub upgrade {
    my $dh = shift;
    # We always prepare the upgrade for just one version. If we can't get
    # to $version-1 from where we are, someone else screwed up.
    if ($option{prepare}) {
        _ignoring_existing_files {
            $dh->prepare_deploy;
        };

        _ignoring_existing_files {
            $dh->prepare_upgrade({
                from_version => $version - 1,
                to_version => $version,
            });
        };
    }

    $dh->upgrade({
        from_version => $dh->database_version,
        to_version => $version
    });
}

sub deploy {
    my $dh = shift;
    
    if ($option{init}) {
        init($dh);
    }

    $dh->deploy({
        version => $version
    });
}

sub prepare {
    my $dh = shift;

    my ($from, $to) = split /-/, $version;

    if ($from == $schema->schema_version) {
        _ignoring_existing_files {
            $dh->prepare_deploy
        };
        _ignoring_existing_files {
            $dh->prepare_upgrade({
                from_version => $from - 1,
                to_version => $from
            });
        };
    }
    else {
        $to ||= $schema->schema_version;
        _ignoring_existing_files {
            $dh->prepare_upgrade({
                from_version => $from,
                to_version => $to,
            })
        };
    }
}

sub _ignoring_existing_files(&) {
    my $coderef = shift;
    try {
        $coderef->();
    }
    catch {
        if (/Cannot overwrite/) {
            say "INFO: Ignoring message: $_";
            return;
        }
        die $_;
    };
}

=head1 SYNOPSIS

    deploy.pl [--target VERSION] [--connection-info|-c DSN] [--force|-f]
        [--init] [--prepare|--ddl] [--user|-u USER] [--password|-p PASSWORD]
        COMMAND

Works with DBIx::Class::DeploymentHandler to upgrade or downgrade the database
between versions.

If you don't have any DeploymentHandler infrastructure yet, use C<init> and then
C<deploy>.

If you have the DH versioning table but not the app's own tables, use C<deploy>.

If you have the app's tables but not the versioning table, use C<init>.
You will need to version your schema first.

If you have both, use C<upgrade>.

To perform an upgrade without releasing a new version of the schema, you can use
C<-f> to recreate the current version's source files, or C<downgrade> and then
C<upgrade> again.

=head1 OPTIONS

=head2 --prepare

=head2 --dsl

When performing a command that requires SQL or DSL (YAML) source files, prepare
them first. The default is to assume that these files are already available in
the module's sharedir.

If the source files already exist you will get an error. Use C<-f> to replace
them - at your own risk.

=head2 --init

When deploying, also initialise. Equivalent to running init and then deploy.

=head2 --force

=head2 -f

Force overwriting of source files. Use this to redeploy the current version
during development.

=head2 --connection-info=DSN

=head2 -c DSN

Provide a connection string (DSN) for the database.

    deploy.pl -c dbi:Pg:dbname=myapp

=head2 --target VERSION

Target this version number. Not all commands accept a target. Defaults to the
current schema version.

=head2 --user=USER

=head2 -u USER

Username with which to connect to the database. Not used if not provided.

=head2 --password=PASSWORD

=head2 -p PASSWORD

Password with which to connect to the database. Not used if not provided.

=head1 COMMANDS

=head2 init

Deploys just the DH versioning table, and registers the current schema version
therein.

If your schema is not yet versioned, you should version it before you do this.

Note that schema versions are integers only.

If you want to deploy the actual schema, use C<deploy>.

=head2 deploy

Deploys the schema at the target version. If you don't have the source files for
this yet, either use L<prepare> or provide the C<--prepare> option.

If you haven't got a versioning table yet, you should use L<init> or provide
L<--init>.

=head2 set-version

If you have the tables but you've gone out of sync, use this with C<--target> to
set the current version in the versioning table.

=head2 upgrade

Upgrades one step at a time until the DB version equals the schema version.
Requires that you have the C<sql/DBTYPE/upgrade/X-Y/*> files in the module's
sharedir, where X-Y represents each stepwise increment up to the current
version.

If you don't have those, C<--prepare> or the L<prepare> command can create the
very latest step for you; but if you need previous versions, someone screwed up
and you'll have to attend to it manually.

=head2 downgrade

Destructive reverse of upgrade. Use at your own risk.

=head2 prepare

With prepare, C<--target> may be a range, in the form of 
I<< <version> >>-I<< <version> >>. This will prepare the upgrade files for this
version range. This requires the YAML files for those two versions.

If C<--target> is not a range, then we can only prepare the deployment files for
the version of the database we are currently on. Therefore, if the target
version is not the current version, we prepare the version files for the range
I<< <target> >>-I<< <current version> >>.
