#!perl

use strict;
use warnings;
use 5.014;

use Pod::Usage;
use Try::Tiny;
use DBIx::Class::DeploymentHandler;
use Getopt::Long qw(:config gnu_getopt);
use File::ShareDir 'module_dir';

my %option = (
    help => sub { pod2usage(verbose => 2) },
);
GetOptions(\%option, 
    'target=f', 
    'help|h|?', 
    'connection-info|c=s', 
    'user|u=s', 
    'password|p=s', 
    'force|f',
    'prepare|ddl',
    'init',
);

my $module = shift;
my $command = shift;

eval "require $module";

my $schema = $module->connect({
    dsn => $option{'connection-info'} // '',
    user => $option{'user'},
    password => $option{'password'},
});
my $dh = DBIx::Class::DeploymentHandler->new({ 
    schema => $schema,
    force_overwrite  => $option{force},
    script_directory => module_dir($module) . '/sql',
});

my $version = $option{target} || $schema->schema_version;

my %command = (
    init => \&init,
    downgrade => \&downgrade,
    upgrade => \&upgrade,
    deploy => \&deploy,
    'set-version' => \&set_version,
    prepare => \&prepare,
);

$command{$command || 'upgrade'}->($dh);

sub _ignoring_existing_files(&);

sub init {
    my $dh = shift;

    if ($option{prepare}) {
        _ignoring_existing_files {
            $dh->prepare_version_storage_install;
        };
    }

    $dh->install_version_storage({
        version => $version
    });

    set_version;
}

sub set_version {
    my $dh = shift;

    try {
        $dh->add_database_version({ 
            version => $version 
        });
        say "Database set to version $version";
    }
    catch {
        if (/Key.+already exists/) {
            say "Already on version $version";
            return 0;
        }
        else {
            die $_;
        }
    };
}

sub downgrade {
    my $dh = shift;
    if ($option{prepare}) {
        # unlikely we'd be here without the deploy, but you never know.
        _ignoring_existing_files {
            $dh->prepare_deploy;
        };

        _ignoring_existing_files {
            $dh->prepare_downgrade;
        }
    }

    $dh->downgrade({
        to_version => $version
    });
}

sub upgrade {
    my $dh = shift;

    # We always prepare the upgrade for just one version. If we can't get
    # to $version-1 from where we are, someone else screwed up.
    if ($option{prepare}) {
        _ignoring_existing_files {
            $dh->prepare_deploy;
        };

        _ignoring_existing_files {
            $dh->prepare_upgrade({
                from_version => $version - 1,
                to_version => $version,
            });
        };
    }

    $dh->upgrade({
        from_version => $dh->database_version,
        to_version => $version
    });
}

sub deploy {
    my $dh = shift;
    if ($option{prepare}) {
        _ignoring_existing_files {
            $dh->prepare_deploy;
        };
    }
    
    $dh->install({
        version => $version
    });
}

sub prepare {
    my $dh = shift;

    my ($from, $to) = split /-/, $version;

    if ($from == $schema->schema_version) {
        _ignoring_existing_files {
            $dh->prepare_deploy
        };
        _ignoring_existing_files {
            $dh->prepare_upgrade({
                from_version => $from - 1,
                to_version => $from
            });
        };
    }
    else {
        $to ||= $schema->schema_version;
        _ignoring_existing_files {
            if ($from > $to) {
                $dh->prepare_downgrade({
                    from_version => $from,
                    to_version => $to,
                });
            }
            else {
                $dh->prepare_upgrade({
                    from_version => $from,
                    to_version => $to,
                })
            }
        };
    }
}

sub _ignoring_existing_files(&) {
    my $coderef = shift;
    try {
        $coderef->();
    }
    catch {
        if (/Cannot overwrite/) {
            say "INFO: Ignoring message: $_";
            return;
        }
        die $_;
    };
}

=head1 SYNOPSIS

    fb11-dbh [--target VERSION] [--connection-info|-c DSN] [--force|-f]
        [--init] [--prepare|--ddl] [--user|-u USER] [--password|-p PASSWORD]
        SCHEMA COMMAND

Works with DBIx::Class::DeploymentHandler to upgrade or downgrade the database
between versions.

I<SCHEMA> is the module name of the schema, e.g. C<MyApp::DBIC::Schema>.
I<COMMAND> is one of the commands listed below.

In general:

=over

=item If you don't have any DeploymentHandler infrastructure yet, use C<deploy>.

=item If you have the app's tables but not the versioning table, use C<init>.
You will need to version your schema first.

=item If you have both, use C<upgrade>.

=item If you have the DH versioning table but not the app's own tables, you
might as well just start again. That table holds no value.

=back

To perform an upgrade without releasing a new version of the schema, you can use
C<-f> to recreate the current version's source files, or C<downgrade> and then
C<upgrade> again.

=head1 COMMANDS

=head2 deploy

Deploys the entire lot at the target version. If you don't have the source files
for this yet, either use L<prepare> or provide the C<--prepare> option. 

=head2 set-version

If you have the tables but you've gone out of sync, use this with C<--target> to
set the current version in the versioning table.

=head2 upgrade

Upgrades one step at a time until the DB version equals the schema version.
Requires that you have the C<sql/DBTYPE/upgrade/X-Y/*> files in the module's
sharedir, where X-Y represents each stepwise increment up to the current
version.

If you don't have those, C<--prepare> or the L<prepare> command can create the
very latest step for you; but if you need previous versions, someone screwed up
and you'll have to attend to it manually.

=head2 downgrade

Destructive reverse of upgrade. Use at your own risk.

=head2 prepare

With prepare, C<--target> may be a range, in the form of 
I<< <version> >>-I<< <version> >>. This will prepare the upgrade files for this
version range. This requires the YAML files for those two versions.

If C<--target> is not a range, then we can only prepare the deployment files for
the version of the database we are currently on. Therefore, if the target
version is not the current version, we prepare the version files for the range
I<< <target> >>-I<< <current version> >>.

    # Requires you are on version 10. Produces _source/deploy/10 YAML
    fb11-dbh -c dbi:Pg:mydb MyApp::DB::Schema prepare 10
    
    # Requires _source/deploy/9 and _source/deploy/10 YAML files. Prepares
    # */upgrade/9-10 SQL files
    fb11-dbh -c dbi:Pg:mydb MyApp::DB::Schema prepare 9-10

    # As above, but a downgrade
    fb11-dbh -c dbi:Pg:mydb MyApp::DB::Schema prepare 10-9

=head2 init

Deploys just the DH versioning table, and registers the current schema version
therein.

You should use this when converting an existing schema to DH. This means you
will have to convert your versioning system to use integers.

=head1 OPTIONS

=head2 --prepare

=head2 --dsl

When performing a command that requires SQL or DSL (YAML) source files, prepare
them first. The default is to assume that these files are already available in
the module's sharedir.

If the source files already exist, this will be noted on STDOUT and processing
continues. You may have them replaced by providing the C<--force> option.

You cannot prepare source files for a version you are not on. Past versions
should be in version control.

=head2 --force

=head2 -f

Force overwriting of source files. Use this to redeploy the current version
during development.

=head2 --connection-info=DSN

=head2 -c DSN

Provide a connection string (DSN) for the database.

    deploy.pl -c dbi:Pg:dbname=myapp

=head2 --target VERSION[-VERSION]

Target this version number. Not all commands accept a target. Some commands
accept a range.

Defaults to the current schema version.

=head2 --user=USER

=head2 -u USER

Username with which to connect to the database. Not used if not provided.

=head2 --password=PASSWORD

=head2 -p PASSWORD

Password with which to connect to the database. Not used if not provided.

=head1 EXAMPLE PROCEDURE

=head2 Development

=over

=item 1 Set the C<$VERSION> of your schema to the next integer.

=item 1 Make changes to your Result classes. These define your schema.

=item 1 If this is the first version, deploy. If not, upgrade.

    fb11-dbh -c dbi:Pg:dbname=mydb MyApp::DB::Schema --prepare -f deploy
    fb11-dbh -c dbi:Pg:dbname=mydb MyApp::DB::Schema --prepare -f upgrade

This will create YAML files that represent the schema (C<_source/deploy/*>), and
the SQL associated therewith (C<PostgreSQL/deploy/*> and
C<PostgreSQL/upgrade/*-*/>).

=item 1 If you have more changes to make, GOTO 2. The files will be overwritten
as needed.

=item 1 Commit the YAML files for the deployment, and the upgrade SQL. If this
is the first version, commit the deploy SQL instead.

=item 1 If this is I<not> the first version, the C<deploy/*> SQL is not needed.
B<Always keep the C<deploy/*> YAML files.>

=item 1 Release all of this. GOTO 1.

=back

=head2 Production

=over

=item 1 Install the latest version of C<MyApp::DB::Schema>.

=item 1 If a new database, use C<deploy>. If not, use C<upgrade>

    fb11-dbh -c dbi:Pg:dbname=mydb_prod MyApp::DB::Schema deploy
    fb11-dbh -c dbi:Pg:dbname=mydb_prod MyApp::DB::Schema upgrade

=item 1 Log out. Make coffee.

=back

Production deployment relies on your having correctly created the necessary
deployment and upgrade SQL files and added them to the distribution. The script
ensures that the module's sharedir is used to create and find these files, so as
long as the deployment process is using sharedir (which it will, because of
Dist::Zilla), you should always have the required files, and DH will just
straight up run them.
